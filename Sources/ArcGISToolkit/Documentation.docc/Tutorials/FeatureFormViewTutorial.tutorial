@Tutorial(time: 10) {
    @Intro(title: "FeatureFormView Tutorial") {
        A `FeatureFormView` is a view that provides an easy way for developers to
        add feature attribute editing capabilities to their existing applications.
        
        @Image(source: FeatureFormView, alt: "An image of the FeatureFormView component.")
    }
    
    @Section(title: "Building a simple editing workflow with FeatureFormView") {
        @ContentAndMedia {
            @Image(source: FeatureFormView, alt: "An image of the FeatureFormView component")
        }
        
        @Steps {
            @Step {
                To begin, add some basic state properties and the base view.
                
                Nest the `MapView` within a `MapViewReader` in order to be able
                to identify features in the map in later steps.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep1.swift)
            }
            
            @Step {
                Add the view modifiers onto the `MapView` necessary to support a
                form editing experience.
                
                Identifying features that have been tapped on in the map is an
                asynchronous operation. Tap locations on the map are captured 
                with `onSingleTapGesture(perform:)` and the provided location is
                used as an identifier to start the asynchronous identify operation.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep2.swift)
            }
            
            @Step {
                After edits have been saved in the ``FeatureFormView``, they 
                need to be applied to the appropriate service geodatabase or 
                feature table.
                
                In order to capture and represent the various possibly different
                points of failure, add `SubmissionError`.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep3.swift)
            }
            
            @Step {
                Add the `applyEdits()` method.
                
                The method sequentially applies edits to all modified tables.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep4.swift)
            }
            
            @Step {
                Add the `makeFeatureForm(point:map:)` method.
                
                The method performs the asynchronous feature identification
                operation and then updates the `featureForm` state variable with
                a feature form, constructed from the first identified feature.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep5.swift)
            }
            
            @Step {
                Add the remaining necessary computed properties.
                
                Note that in `featureFormView` the 
                ``FeatureFormView/onFormEditingEvent(perform:)`` modifier is 
                used to watch when edits are saved in the ``FeatureFormView``. 
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep6.swift)
            }
            
            @Step {
                Finally, add two more computed properties.
                
                The first property combines errors from applying edits into a 
                single array.
                @Code(name: "FeatureFormExampleView.swift", file: FeatureFormViewTutorialStep7.swift)
            }
        }
    }
    
    @Section(title: "FeatureFormView customization") {
        @ContentAndMedia {
            FeatureFormView has various customizations available to support 
            different use-cases.
        }
        
        @Steps {
            @Step {
                The close button in the header of ``FeatureFormView`` can be 
                hidden by simply omitting the `isPresented` parameter in the 
                initializer.
                
                Use this to retain programatic control over when the form view
                is closed.
                @Code(name: "FeatureFormViewCustomizationExample.swift", file: FeatureFormViewTutorialStep8.swift)
            }
            
            @Step {
                The "Save" and "Discard" buttons in the ``FeatureFormView`` can
                be hidden with ``FeatureFormView/editingButtons(_:)``.
                
                Use this modifier when "Save" and "Discard" buttons are provided
                at the application level.
                @Code(name: "FeatureFormViewCustomizationExample.swift", file: FeatureFormViewTutorialStep9.swift)
            }
            
            @Step {
                ``FeatureFormView`` automatically handles showing validation 
                errors at relevant times. To override this behavior and make 
                validation errors always visible, use 
                ``FeatureFormView/validationErrors(_:)``.
                @Code(name: "FeatureFormViewCustomizationExample.swift", file: FeatureFormViewTutorialStep10.swift)
            }
        }
    }
        
    @Section(title: "Browsing utility associations with FeatureFormView") {
        @ContentAndMedia {
            FeatureFormView supports browsing associated features via the
            `UtilityAssociationsFormElement`.
        }
        
        @Steps {
            @Step {
                FeatureFormView uses an internal `NavigationStack` to navigate 
                between forms for utility associations.
                
                To support browsing utility associations without conflicting
                with app-level navigation, present the ``FeatureFormView`` 
                outside of any app-level navigation context. An Inspector or 
                <doc:FloatingPanel> can be used to present the 
                ``FeatureFormView`` while keeping the map view visible and
                interactive. An `@Observable` object can be used to synchronize
                state between views within app-level navigation and the 
                ``FeatureFormView``.
                @Code(name: "FeatureFormViewUtilityAssociationsExample.swift", file: FeatureFormViewTutorialStep11.swift)
            }
            
            @Step {
                Edits can always be made to a feature outside of the feature 
                form context.
                
                To temporarily prevent a user from navigating to a different
                feature, use ``FeatureFormView/navigationDisabled(_:)``.
                @Code(name: "FeatureFormViewUtilityAssociationsExample.swift", file: FeatureFormViewTutorialStep12.swift)
            }
            
            @Step {
                Use ``FeatureFormView/onFeatureFormChanged(perform:)`` to track
                when a user has navigated to a new feature.
                @Code(name: "FeatureFormViewUtilityAssociationsExample.swift", file: FeatureFormViewTutorialStep13.swift)
            }
            
            @Step {
                Navigating to other features is blocked when the current feature
                form has edits. Users will be given the option to save their
                edits (if there are no validation errors), discard their edits
                or continue editing (cancelling the navigation).
                
                To build an editing experience where the form is dismissed when
                edits are saved or discarded, but only when the user wasn't 
                navigating, interpret the value of `willNavigate`.
                ``FeatureFormView/onFormEditingEvent(perform:)``.
                @Code(name: "FeatureFormViewUtilityAssociationsExample.swift", file: FeatureFormViewTutorialStep14.swift)
            }
        }
    }
}
